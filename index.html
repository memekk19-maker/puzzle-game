<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Slide Puzzle</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#09131a;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.09);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --accent:#7cf7d4;
      --danger:#ff5a7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --tileRadius: 16px;
      --gap: 10px;
      --tap: 44px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(124,247,212,.18), transparent 60%),
        radial-gradient(900px 700px at 90% 30%, rgba(120,154,255,.16), transparent 62%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding: max(14px, env(safe-area-inset-top)) 14px max(14px, env(safe-area-inset-bottom));
      gap:12px;
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }

    .hud{
      flex:1;
      background:var(--card);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      padding:12px 12px;
      box-shadow: var(--shadow);
    }
    .hudTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .title{
      font-weight:800;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:16px;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: linear-gradient(135deg, var(--accent), #7aa9ff);
      box-shadow: 0 0 16px rgba(124,247,212,.45);
    }
    .stats{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
    }
    .stat{
      background: var(--card2);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 10px;
      min-height:56px;
    }
    .k{
      font-size:11px;
      color:var(--muted);
      margin-bottom:4px;
      letter-spacing:.2px;
    }
    .v{
      font-size:18px;
      font-weight:800;
      line-height:1.1;
    }
    .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .menuBtn{
      min-width: var(--tap);
      height: var(--tap);
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      box-shadow: var(--shadow);
      display:grid;
      place-items:center;
      font-size:18px;
      cursor:pointer;
    }
    .menuBtn:active{transform:translateY(1px)}

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    .panel{
      background:var(--card);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    /* Board area */
    .boardWrap{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .boardHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .sizePill{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      font-size:12px;
      line-height:1;
    }
    .sizePill b{color:var(--text)}
    .hintPill{
      padding:8px 10px;
      border-radius: 999px;
      border:1px dashed rgba(124,247,212,.35);
      background: rgba(124,247,212,.08);
      color: rgba(124,247,212,.95);
      font-size:12px;
      display:none;
      align-items:center;
      gap:8px;
    }
    .hintArrow{
      width:0;height:0;
      border-top:6px solid transparent;
      border-bottom:6px solid transparent;
      border-left:10px solid rgba(124,247,212,.95);
      filter: drop-shadow(0 0 6px rgba(124,247,212,.35));
    }

    .board{
      position:relative;
      width:min(92vw, 520px);
      max-width: 520px;
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      border-radius: 22px;
      background:
        radial-gradient(500px 500px at 25% 20%, rgba(255,255,255,.08), transparent 55%),
        radial-gradient(500px 500px at 75% 80%, rgba(124,247,212,.08), transparent 55%),
        rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12), var(--shadow);
      overflow:hidden;
      touch-action:none; /* allow swipe */
    }

    .tile{
      position:absolute;
      border-radius: var(--tileRadius);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size: clamp(20px, 6vw, 40px);
      letter-spacing: .4px;
      color: rgba(10,18,26,.92);
      background:
        radial-gradient(120px 120px at 25% 25%, rgba(255,255,255,.75), rgba(255,255,255,.28) 62%, rgba(255,255,255,.20)),
        linear-gradient(135deg, rgba(124,247,212,.92), rgba(122,169,255,.88));
      box-shadow:
        0 10px 18px rgba(0,0,0,.32),
        inset 0 0 0 1px rgba(255,255,255,.35);
      cursor:pointer;
      transform: translate3d(0,0,0);
      transition: transform 220ms cubic-bezier(.2,.8,.2,1);
      will-change: transform;
    }
    .tile::after{
      content:"";
      position:absolute;
      inset:1px;
      border-radius: calc(var(--tileRadius) - 1px);
      background: linear-gradient(180deg, rgba(255,255,255,.18), transparent 55%);
      pointer-events:none;
      mix-blend-mode: overlay;
    }
    .tile:active{
      filter: brightness(1.02);
      transform: translate3d(var(--tx,0px), var(--ty,0px), 0) scale(.985);
    }

    .tile.badge{
      outline: 2px solid rgba(124,247,212,.55);
      box-shadow:
        0 12px 22px rgba(0,0,0,.34),
        0 0 0 2px rgba(124,247,212,.25),
        0 0 24px rgba(124,247,212,.22),
        inset 0 0 0 1px rgba(255,255,255,.35);
    }

    /* Controls */
    .controls{
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:10px;
    }
    .btn{
      height:46px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      font-weight:800;
      font-size:14px;
      letter-spacing:.2px;
      box-shadow: 0 10px 18px rgba(0,0,0,.22);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:0 10px;
      min-width: var(--tap);
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{color:var(--muted)}
    .btn.good{border-color: rgba(124,247,212,.35)}
    .btn.warn{border-color: rgba(255,90,122,.35); color: rgba(255,210,220,.95)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn .mini{font-size:12px; opacity:.9}

    @media (max-width: 420px){
      .controls{grid-template-columns: repeat(3, minmax(0, 1fr));}
      .btn{height:48px}
    }

    /* Overlays */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      z-index: 50;
    }
    .modal{
      width: min(560px, 92vw);
      background: rgba(18,22,32,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 20px;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .modal h2{
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing:.2px;
    }
    .modal p, .modal li{
      margin: 6px 0;
      color: rgba(255,255,255,.80);
      line-height:1.45;
      font-size: 13px;
    }
    .modal .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .modal .row .btn{flex:1}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.82);
      font-size: 12px;
      margin-right: 6px;
    }
    .kbd{
      padding:2px 7px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.25);
      font-weight: 800;
      font-size: 11px;
      color: rgba(255,255,255,.88);
    }

    .toast{
      position:fixed;
      left:50%;
      bottom: calc(18px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      background: rgba(18,22,32,.92);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.88);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      opacity:0;
      pointer-events:none;
      transition: opacity 180ms ease, transform 180ms ease;
      z-index: 60;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }

    canvas#confetti{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
      z-index: 55;
      display:none;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="hud" id="hud">
        <div class="hudTop">
          <div class="title"><span class="dot"></span>Slide Puzzle</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="pill" id="modePill">4√ó4</span>
            <span class="pill" id="soundPill">üîä ON</span>
          </div>
        </div>
        <div class="stats">
          <div class="stat">
            <div class="k">moves</div>
            <div class="v" id="moves">0</div>
            <div class="sub" id="bestMoves">best: ‚Äî</div>
          </div>
          <div class="stat">
            <div class="k">time</div>
            <div class="v" id="time">0:00</div>
            <div class="sub" id="bestTime">best: ‚Äî</div>
          </div>
          <div class="stat">
            <div class="k">status</div>
            <div class="v" id="status">PLAY</div>
            <div class="sub" id="msg">Tap tiles / Swipe</div>
          </div>
        </div>
      </div>
      <button class="menuBtn" id="menuBtn" aria-label="menu">‚â°</button>
    </header>

    <main>
      <section class="panel">
        <div class="boardWrap">
          <div class="boardHeader">
            <div class="sizePill" id="sizePill">Size: <b id="sizeLabel">4√ó4</b></div>
            <div class="hintPill" id="hintPill"><span class="hintArrow" id="hintArrow"></span><span id="hintText">hint</span></div>
          </div>
          <div class="board" id="board" aria-label="board"></div>
        </div>

        <div class="controls">
          <button class="btn good" id="newBtn">New</button>
          <button class="btn" id="undoBtn" disabled>Undo</button>
          <button class="btn" id="sizeBtn">Size <span class="mini" id="sizeMini">4√ó4</span></button>
          <button class="btn secondary" id="hintBtn">Hint</button>
          <button class="btn secondary" id="soundBtn">Sound</button>
        </div>
      </section>
    </main>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal" role="dialog" aria-modal="true">
      <h2 id="overlayTitle">Menu</h2>
      <div id="overlayBody">
        <p>
          <span class="pill">Tap</span> Á©∫ÁôΩ„ÅÆÈö£„ÅÆ„Çø„Ç§„É´„ÇíÁßªÂãï<br/>
          <span class="pill">Swipe</span> Áõ§Èù¢„Çí„Çπ„ÉØ„Ç§„ÉóÔºà„Çø„Ç§„É´„ÅåÊåá„ÅÆÊñπÂêë„Å´Âãï„ÅèÊÑü„ÅòÔºâ
        </p>
        <p>
          PCÊìç‰ΩúÔºö<span class="kbd">WASD</span>/<span class="kbd">‚Üë‚Üì‚Üê‚Üí</span>ÔºàÁ©∫ÁôΩÁßªÂãïÔºâ„ÄÅ
          <span class="kbd">R</span> New„ÄÅ<span class="kbd">Z</span> Undo
        </p>
        <p style="color:rgba(255,255,255,.72)">
          ‚Äª„Ç∑„É£„ÉÉ„Éï„É´„ÅØÂøÖ„ÅöËß£„Åë„ÇãÁä∂ÊÖã„Åã„ÇâÂêàÊ≥ïÊâã„Çí„É©„É≥„ÉÄ„É†„Å´Âãï„Åã„Åó„Å¶‰Ωú„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
        </p>
      </div>
      <div class="row">
        <button class="btn" id="resumeBtn">Resume</button>
        <button class="btn secondary" id="resetBestBtn">Reset Best</button>
      </div>
    </div>
  </div>

  <canvas id="confetti"></canvas>
  <div class="toast" id="toast">Saved</div>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const fmtTime = (ms) => {
    const s = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return `${m}:${String(r).padStart(2,"0")}`;
  };
  const now = () => performance.now();

  // ---------- DOM ----------
  const boardEl = $("#board");
  const movesEl = $("#moves");
  const timeEl = $("#time");
  const bestMovesEl = $("#bestMoves");
  const bestTimeEl = $("#bestTime");
  const statusEl = $("#status");
  const msgEl = $("#msg");
  const sizeLabelEl = $("#sizeLabel");
  const sizeMiniEl = $("#sizeMini");
  const sizePillEl = $("#sizePill");
  const modePillEl = $("#modePill");
  const soundPillEl = $("#soundPill");

  const newBtn = $("#newBtn");
  const undoBtn = $("#undoBtn");
  const sizeBtn = $("#sizeBtn");
  const hintBtn = $("#hintBtn");
  const soundBtn = $("#soundBtn");
  const menuBtn = $("#menuBtn");

  const overlay = $("#overlay");
  const overlayTitle = $("#overlayTitle");
  const resumeBtn = $("#resumeBtn");
  const resetBestBtn = $("#resetBestBtn");

  const hintPill = $("#hintPill");
  const hintArrow = $("#hintArrow");
  const hintText = $("#hintText");

  const toast = $("#toast");

  const confettiCanvas = $("#confetti");
  const cctx = confettiCanvas.getContext("2d");

  // ---------- Settings / Storage ----------
  const LS_KEY = "slide_puzzle_v1";
  const loadLS = () => {
    try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
    catch { return {}; }
  };
  const saveLS = (obj) => localStorage.setItem(LS_KEY, JSON.stringify(obj));
  let store = loadLS();

  let size = store.size || 4; // 3/4/5
  let soundOn = (store.soundOn ?? true);

  const bestKeyMoves = (n) => `bestMoves_${n}`;
  const bestKeyTime  = (n) => `bestTime_${n}`;

  // ---------- Audio (WebAudio beeps) ----------
  let audioCtx = null;
  const ensureAudio = () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  };
  const beep = (freq=440, dur=0.05, type="sine", vol=0.05) => {
    if (!soundOn) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  };
  const sfx = {
    move: () => beep(520, 0.045, "triangle", 0.05),
    bump: () => beep(180, 0.06, "sine", 0.06),
    undo: () => beep(360, 0.05, "sine", 0.05),
    clear: () => { beep(740, 0.06, "triangle", 0.06); setTimeout(()=>beep(980, 0.07, "triangle", 0.06), 70); },
    click: () => beep(320, 0.03, "square", 0.04),
    hint: () => beep(640, 0.04, "sine", 0.04),
  };

  // ---------- Game State ----------
  let board = [];          // length N*N, 0 is blank
  let blank = 0;           // index of blank
  let moves = 0;
  let solved = false;

  let animLock = false;    // prevent input during animation
  let undoStack = [];      // snapshots
  const UNDO_MAX = 60;

  let running = true;
  let tStart = 0;
  let tPausedAt = 0;
  let tAccumPause = 0;
  let rafId = 0;

  // tile DOM map by value
  const tileEls = new Map();

  // layout
  let cell = 0, gap = 0, pad = 0; // computed px
  const getXY = (idx) => ({ x: idx % size, y: Math.floor(idx / size) });

  // ---------- Confetti ----------
  let confetti = [];
  let confettiEnd = 0;

  const resizeConfetti = () => {
    const dpr = window.devicePixelRatio || 1;
    confettiCanvas.width = Math.floor(innerWidth * dpr);
    confettiCanvas.height = Math.floor(innerHeight * dpr);
    confettiCanvas.style.width = innerWidth + "px";
    confettiCanvas.style.height = innerHeight + "px";
    cctx.setTransform(dpr,0,0,dpr,0,0);
  };

  const startConfetti = () => {
    resizeConfetti();
    confettiCanvas.style.display = "block";
    confettiEnd = now() + 1400;
    confetti.length = 0;
    const n = 120;
    for (let i=0;i<n;i++){
      confetti.push({
        x: innerWidth * (0.2 + Math.random()*0.6),
        y: -20 - Math.random()*innerHeight*0.2,
        vx: (Math.random()*2 - 1) * 2.2,
        vy: 3 + Math.random()*3.2,
        r: 3 + Math.random()*5,
        rot: Math.random()*Math.PI,
        vr: (Math.random()*2 - 1) * 0.18,
        hue: 160 + Math.random()*140,
        a: 0.95
      });
    }
  };

  const drawConfetti = () => {
    if (confettiCanvas.style.display !== "block") return;
    cctx.clearRect(0,0,innerWidth, innerHeight);
    const t = now();
    const alive = t < confettiEnd;
    for (const p of confetti){
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.035;
      p.rot += p.vr;
      p.a *= 0.995;
      cctx.save();
      cctx.translate(p.x, p.y);
      cctx.rotate(p.rot);
      cctx.globalAlpha = Math.max(0, Math.min(1, p.a));
      cctx.fillStyle = `hsl(${p.hue} 90% 60%)`;
      cctx.fillRect(-p.r, -p.r*0.6, p.r*2, p.r*1.2);
      cctx.restore();
    }
    if (!alive){
      confettiCanvas.style.display = "none";
    }
  };

  // ---------- UI ----------
  const showToast = (text) => {
    toast.textContent = text;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), 900);
  };

  const updateHUD = () => {
    movesEl.textContent = String(moves);
    const t = solved ? getElapsedMs() : getElapsedMs();
    timeEl.textContent = fmtTime(t);

    const bm = store[bestKeyMoves(size)];
    const bt = store[bestKeyTime(size)];
    bestMovesEl.textContent = `best: ${bm != null ? bm : "‚Äî"}`;
    bestTimeEl.textContent  = `best: ${bt != null ? fmtTime(bt) : "‚Äî"}`;

    const label = `${size}√ó${size}`;
    sizeLabelEl.textContent = label;
    sizeMiniEl.textContent = label;
    sizePillEl.innerHTML = `Size: <b id="sizeLabel">${label}</b>`;
    modePillEl.textContent = label;
    soundPillEl.textContent = soundOn ? "üîä ON" : "üîá OFF";

    undoBtn.disabled = undoStack.length === 0 || animLock || solved;
  };

  const setStatus = (st, msg="") => {
    statusEl.textContent = st;
    msgEl.textContent = msg || (st === "PLAY" ? "Tap tiles / Swipe" : "");
  };

  const openOverlay = (title="Menu") => {
    overlayTitle.textContent = title;
    overlay.style.display = "flex";
    pauseTimer();
  };
  const closeOverlay = () => {
    overlay.style.display = "none";
    resumeTimer();
  };

  // ---------- Timer ----------
  const resetTimer = () => {
    tStart = now();
    tAccumPause = 0;
    tPausedAt = 0;
  };
  const pauseTimer = () => {
    if (!running) return;
    running = false;
    tPausedAt = now();
  };
  const resumeTimer = () => {
    if (running) return;
    running = true;
    if (tPausedAt) tAccumPause += (now() - tPausedAt);
    tPausedAt = 0;
  };
  const getElapsedMs = () => {
    const t = running ? now() : (tPausedAt || now());
    return Math.max(0, t - tStart - tAccumPause);
  };

  // ---------- Board layout ----------
  const computeLayout = () => {
    const rect = boardEl.getBoundingClientRect();
    const w = rect.width;
    // Use CSS gap variable conceptually
    gap = Math.max(8, Math.min(14, Math.floor(w * 0.028)));
    pad = gap;
    const inner = w - pad*2 - gap*(size-1);
    cell = inner / size;
  };

  const setTilePos = (val, idx, instant=false) => {
    const el = tileEls.get(val);
    if (!el) return;
    const {x,y} = getXY(idx);
    const tx = pad + x*(cell + gap);
    const ty = pad + y*(cell + gap);
    el.style.width = `${cell}px`;
    el.style.height = `${cell}px`;
    // Use translate3d for smooth animation
    if (instant){
      el.style.transition = "none";
      el.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
      // force reflow then restore
      el.offsetHeight; // eslint-disable-line no-unused-expressions
      el.style.transition = "transform 220ms cubic-bezier(.2,.8,.2,1)";
    }else{
      el.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
    }
    el.style.setProperty("--tx", `${tx}px`);
    el.style.setProperty("--ty", `${ty}px`);
  };

  const renderAll = (instant=false) => {
    computeLayout();
    // update board element padding (visual)
    boardEl.style.setProperty("--gap", `${gap}px`);
    // position each tile by current index
    for (let i=0;i<board.length;i++){
      const v = board[i];
      if (v !== 0) setTilePos(v, i, instant);
    }
  };

  // ---------- Puzzle logic ----------
  const makeSolvedBoard = (n) => {
    const arr = [];
    for (let i=1;i<n*n;i++) arr.push(i);
    arr.push(0);
    return arr;
  };

  const isSolved = () => {
    for (let i=0;i<board.length-1;i++){
      if (board[i] !== i+1) return false;
    }
    return board[board.length-1] === 0;
  };

  const neighborsOfBlank = () => {
    const b = blank;
    const {x,y} = getXY(b);
    const list = [];
    if (x > 0) list.push(b - 1);
    if (x < size-1) list.push(b + 1);
    if (y > 0) list.push(b - size);
    if (y < size-1) list.push(b + size);
    return list;
  };

  const pushUndo = () => {
    undoStack.push({
      board: board.slice(),
      blank,
      moves,
      t: getElapsedMs()
    });
    if (undoStack.length > UNDO_MAX) undoStack.shift();
  };

  const applyUndo = () => {
    if (undoStack.length === 0 || animLock) return;
    const snap = undoStack.pop();
    board = snap.board.slice();
    blank = snap.blank;
    moves = snap.moves;
    // Restore timer to snapshot time by shifting start
    const target = snap.t;
    tStart = now() - target - tAccumPause;
    solved = false;
    setStatus("PLAY", "Undone");
    sfx.undo();
    renderAll(false);
    updateHUD();
  };

  const swap = (i,j) => {
    const t = board[i];
    board[i] = board[j];
    board[j] = t;
  };

  const moveTileAtIndex = (tileIdx, fromSwipe=false) => {
    if (animLock || solved) return false;
    if (tileIdx < 0 || tileIdx >= board.length) return false;
    const v = board[tileIdx];
    if (v === 0) return false;
    const b = blank;
    const {x:tx,y:ty} = getXY(tileIdx);
    const {x:bx,y:by} = getXY(b);
    const man = Math.abs(tx-bx) + Math.abs(ty-by);
    if (man !== 1) { if (fromSwipe) sfx.bump(); return false; }

    pushUndo();
    // swap tile with blank
    swap(tileIdx, b);
    blank = tileIdx;
    moves += 1;
    sfx.move();

    // animate only the moved tile (others unchanged)
    setTilePos(v, b, false);

    // lock until transition end (fallback timeout)
    animLock = true;
    updateHUD();
    const el = tileEls.get(v);
    let done = false;
    const finish = () => {
      if (done) return;
      done = true;
      animLock = false;
      if (isSolved()){
        solved = true;
        onClear();
      }
      updateHUD();
    };
    const onEnd = (e) => {
      if (e.propertyName !== "transform") return;
      el.removeEventListener("transitionend", onEnd);
      finish();
    };
    el.addEventListener("transitionend", onEnd);
    setTimeout(()=>{ try{ el.removeEventListener("transitionend", onEnd);}catch{} finish(); }, 260);

    return true;
  };

  const moveBlankBy = (dx,dy) => {
    // move blank by swapping with tile in that direction (tile moves opposite)
    const {x,y} = getXY(blank);
    const nx = x + dx, ny = y + dy;
    if (nx < 0 || nx >= size || ny < 0 || ny >= size) return false;
    const tileIdx = ny*size + nx;
    return moveTileAtIndex(tileIdx, true);
  };

  const shuffleSolvable = () => {
    // Start from solved, apply random legal moves many times
    board = makeSolvedBoard(size);
    blank = board.length - 1;
    moves = 0;
    solved = false;
    undoStack = [];
    resetTimer();
    resumeTimer();

    const steps = size === 3 ? 120 : (size === 4 ? 220 : 320);
    let prev = -1;
    for (let s=0;s<steps;s++){
      const neigh = neighborsOfBlank();
      // avoid immediate backtrack if possible
      const options = neigh.filter(i => i !== prev);
      const pickFrom = options.length ? options : neigh;
      const choice = pickFrom[Math.floor(Math.random()*pickFrom.length)];
      prev = blank;
      // swap chosen tile into blank (no animation)
      swap(choice, blank);
      blank = choice;
    }

    // ensure not already solved (rare)
    if (isSolved()) {
      // do one more random move
      const neigh = neighborsOfBlank();
      const choice = neigh[Math.floor(Math.random()*neigh.length)];
      swap(choice, blank);
      blank = choice;
    }

    setStatus("PLAY", "Good luck!");
    rebuildTiles();
    renderAll(true);
    updateHUD();
  };

  const rebuildTiles = () => {
    // clear existing
    boardEl.innerHTML = "";
    tileEls.clear();
    const max = size*size - 1;
    for (let v=1; v<=max; v++){
      const el = document.createElement("div");
      el.className = "tile";
      el.textContent = String(v);
      el.setAttribute("role","button");
      el.setAttribute("aria-label", `tile ${v}`);
      el.addEventListener("click", () => {
        ensureAudio();
        const idx = board.indexOf(v);
        moveTileAtIndex(idx, false);
      }, {passive:true});
      boardEl.appendChild(el);
      tileEls.set(v, el);
    }
  };

  // ---------- Hint (simple) ----------
  const goalPos = (val) => {
    if (val === 0) return {x:size-1, y:size-1};
    const idx = val - 1;
    return {x: idx % size, y: Math.floor(idx / size)};
  };
  const manhattanScore = (arr) => {
    let sum = 0;
    for (let i=0;i<arr.length;i++){
      const v = arr[i];
      if (v === 0) continue;
      const {x,y} = getXY(i);
      const g = goalPos(v);
      sum += Math.abs(x-g.x) + Math.abs(y-g.y);
    }
    return sum;
  };

  let hintTimer = 0;
  const showHint = () => {
    if (animLock || solved) return;
    sfx.hint();
    const neigh = neighborsOfBlank();
    let best = null;
    let bestScore = Infinity;
    for (const idx of neigh){
      const test = board.slice();
      // move tile at idx into blank
      const b = blank;
      const t = test[idx];
      test[idx] = 0;
      test[b] = t;
      const sc = manhattanScore(test);
      if (sc < bestScore){
        bestScore = sc;
        best = {tile: t, idxFrom: idx};
      }
    }
    if (!best) return;

    // highlight tile briefly
    tileEls.forEach(el => el.classList.remove("badge"));
    const el = tileEls.get(best.tile);
    if (el) el.classList.add("badge");

    // show direction arrow (swipe direction that would move that tile)
    const b = blank;
    const {x:bx,y:by} = getXY(b);
    const {x:tx,y:ty} = getXY(best.idxFrom);
    // If tile is left of blank (tx=bx-1), the tile will move right (swipe right)
    let dir = "‚Üí";
    if (tx === bx-1) dir = "‚Üí";
    else if (tx === bx+1) dir = "‚Üê";
    else if (ty === by-1) dir = "‚Üì";
    else if (ty === by+1) dir = "‚Üë";

    // Arrow triangle orientation
    hintArrow.style.transform = ({
      "‚Üí":"rotate(0deg)",
      "‚Üê":"rotate(180deg)",
      "‚Üë":"rotate(-90deg)",
      "‚Üì":"rotate(90deg)"
    })[dir];

    hintText.textContent = `Swipe ${dir} or tap`;
    hintPill.style.display = "inline-flex";

    clearTimeout(hintTimer);
    hintTimer = setTimeout(() => {
      hintPill.style.display = "none";
      tileEls.forEach(el => el.classList.remove("badge"));
    }, 1100);
  };

  // ---------- Clear / Best ----------
  const onClear = () => {
    pauseTimer();
    setStatus("CLEAR", "Nice!");
    sfx.clear();
    startConfetti();

    const t = getElapsedMs();
    const bmKey = bestKeyMoves(size);
    const btKey = bestKeyTime(size);
    const prevMoves = store[bmKey];
    const prevTime  = store[btKey];

    let updated = false;
    if (prevMoves == null || moves < prevMoves){
      store[bmKey] = moves;
      updated = true;
    }
    if (prevTime == null || t < prevTime){
      store[btKey] = t;
      updated = true;
    }
    store.size = size;
    store.soundOn = soundOn;
    saveLS(store);

    updateHUD();
    showToast(updated ? "Best updated!" : "Cleared!");
  };

  // ---------- Input (Swipe / Keys) ----------
  let pDown = false;
  let pStart = {x:0,y:0,t:0};
  const SWIPE_MIN = 18;

  const onPointerDown = (e) => {
    if (animLock) return;
    pDown = true;
    pStart = {x:e.clientX, y:e.clientY, t:now()};
    // allow audio unlock on first interaction
    ensureAudio();
  };
  const onPointerMove = (e) => {
    if (!pDown) return;
  };
  const onPointerUp = (e) => {
    if (!pDown) return;
    pDown = false;
    const dx = e.clientX - pStart.x;
    const dy = e.clientY - pStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const dt = now() - pStart.t;
    if (Math.max(adx, ady) < SWIPE_MIN || dt > 800) return;

    // Determine swipe direction: we interpret swipe so that the *tile* moves along swipe,
    // which means the blank moves opposite direction.
    if (adx > ady){
      if (dx > 0) {
        // swipe right -> tile moves right -> blank moves left
        moveBlankBy(-1, 0);
      } else {
        // swipe left -> blank moves right
        moveBlankBy(1, 0);
      }
    } else {
      if (dy > 0) {
        // swipe down -> blank moves up
        moveBlankBy(0, -1);
      } else {
        // swipe up -> blank moves down
        moveBlankBy(0, 1);
      }
    }
  };

  boardEl.addEventListener("pointerdown", onPointerDown);
  boardEl.addEventListener("pointermove", onPointerMove);
  boardEl.addEventListener("pointerup", onPointerUp);
  boardEl.addEventListener("pointercancel", () => { pDown=false; });

  // Keyboard (PC)
  window.addEventListener("keydown", (e) => {
    if (overlay.style.display === "flex") {
      if (e.key === "Escape") closeOverlay();
      return;
    }
    if (e.key === "Escape") { openOverlay("Menu"); return; }
    if (e.key.toLowerCase() === "r") { sfx.click(); shuffleSolvable(); return; }
    if (e.key.toLowerCase() === "z") { applyUndo(); return; }
    if (e.key.toLowerCase() === "h") { showHint(); return; }

    // Move blank with arrows/WASD (swap with neighbor tile)
    const k = e.key;
    if (k === "ArrowLeft" || k.toLowerCase()==="a") moveBlankBy(1,0);      // blank right => tile left
    else if (k === "ArrowRight" || k.toLowerCase()==="d") moveBlankBy(-1,0);
    else if (k === "ArrowUp" || k.toLowerCase()==="w") moveBlankBy(0,1);
    else if (k === "ArrowDown" || k.toLowerCase()==="s") moveBlankBy(0,-1);
  });

  // ---------- Buttons ----------
  newBtn.addEventListener("click", () => { sfx.click(); shuffleSolvable(); });
  undoBtn.addEventListener("click", () => applyUndo());
  hintBtn.addEventListener("click", () => showHint());

  soundBtn.addEventListener("click", () => {
    soundOn = !soundOn;
    store.soundOn = soundOn;
    saveLS(store);
    updateHUD();
    showToast(soundOn ? "Sound ON" : "Sound OFF");
    if (soundOn) sfx.click();
  });

  sizeBtn.addEventListener("click", () => {
    // cycle 3->4->5
    const next = size === 3 ? 4 : (size === 4 ? 5 : 3);
    size = next;
    store.size = size;
    saveLS(store);
    sfx.click();
    shuffleSolvable();
    showToast(`Size ${size}√ó${size}`);
  });

  menuBtn.addEventListener("click", () => { sfx.click(); openOverlay("Menu"); });
  resumeBtn.addEventListener("click", () => { sfx.click(); closeOverlay(); });
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) closeOverlay();
  });

  resetBestBtn.addEventListener("click", () => {
    const bmKey = bestKeyMoves(size);
    const btKey = bestKeyTime(size);
    delete store[bmKey];
    delete store[btKey];
    saveLS(store);
    updateHUD();
    showToast("Best reset");
    sfx.click();
  });

  // prevent iOS double-tap zoom on buttons
  const fastTapGuard = (el) => {
    let last = 0;
    el.addEventListener("touchend", (e) => {
      const t = Date.now();
      if (t - last <= 300) e.preventDefault();
      last = t;
    }, {passive:false});
  };
  [newBtn, undoBtn, sizeBtn, hintBtn, soundBtn, menuBtn].forEach(fastTapGuard);

  // ---------- Main loop (for time + confetti) ----------
  const loop = () => {
    updateHUD();
    drawConfetti();
    rafId = requestAnimationFrame(loop);
  };

  // ---------- Init ----------
  const init = () => {
    // ensure store exists
    store = loadLS();
    size = store.size || size;
    soundOn = (store.soundOn ?? soundOn);

    // Build
    shuffleSolvable();
    updateHUD();

    // Resize
    const onResize = () => { renderAll(true); resizeConfetti(); };
    window.addEventListener("resize", onResize, {passive:true});
    window.addEventListener("orientationchange", onResize, {passive:true});

    // Start loop
    rafId = requestAnimationFrame(loop);

    // First-run tip
    const tipKey = "slide_puzzle_tip_shown";
    if (!store[tipKey]) {
      store[tipKey] = true;
      saveLS(store);
      setTimeout(() => openOverlay("How to play"), 180);
    }
  };

  init();
})();
</script>
</body>
</html>
